# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя  

```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 3 },
     "ns" : /^db1\./
   }
)
```  
``` db.killOp(opid) ```  
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB  

```
- настроить логирование
db.setProfilingLevel(2)
- выполнить explain на зависающих запросах и поискать причины в запросе
db.collection.explain().count( { quantity: { $gt: 50 } } )
- построить\перестроить индексы
db.collection.createIndex(
  {
      "a": 1
  },
  {
      unique: true,
      sparse: true,
      expireAfterSeconds: 3600
  }
)
можно использовать параметр maxTimeMS() для запросов CRUD в MongoDB
долгие запросы загружают сервер, а также могут вызвать блокировки запросов
``` 

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?  

```
- закончилась оперативная память
- запись заблокирована из-за переполнения выходного буфера или синхронизации данных в буфере
- используются медленно выполняющиеся инструкции
```  
``` В Redis есть два способа очистить просроченные записи: "ленивый" и "активный". В случае с ленивым - просроченные записи истекают когда запрашиваются командой, активный способ - повторяется каждые 100 миллисекунд и проводит записи в состояние устаревшие, затем данные записи исключаются. ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP по умолчанию имеет значение 20, таким образом за раз можно пометить и очистить около 200 устаревших записей. Процесс проверки зациклится и мы ощутим задержки, а потом и вовсе не будут приниматься данные на запись, если появятся истекшие записи более 25% по отношению ко всем. В данном случае как раз так и получается. Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек. ```  

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?  
```
- проблемы с сетью -> проверить и исправить сеть
- долгий запрос -> анализ запроса, прогон через explain, оптимизация
- разрослась база -> шардировать таблицу, добавить ресурсы
```  
``` Как вариант может быть проблема в размере данных BLOB, которое больше чем значение max_allowed_packet -> увеличить значение max_allowed_packet ```  

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?  
```
нехватка памяти -> оптимизировать настройки postgresql, добавить ресурсы
```  
```
настройки связанные с памятью
shared_buffers = 128MB          # min 128kB
#huge_pages = off           # on, off, or try
#temp_buffers = 8MB         # min 800kB
#max_prepared_transactions = 0      # zero disables the feature
#work_mem = 4MB             # min 64kB
#maintenance_work_mem = 64MB        # min 1MB
#replacement_sort_tuples = 150000   # limits use of replacement selection sort
#autovacuum_work_mem = -1       # min 1MB, or -1 to use maintenance_work_mem
#max_stack_depth = 2MB          # min 100kB

требуется снизить потребление оперативной памяти postgresql, чтобы oom-killer не убивал процесс postgresql.
Предполагаю, что развернули postgresql на чистой машине, и нет излишнего потребления оперативной памяти со стороны других процессов.
```
---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
